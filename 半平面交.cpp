//此模板为顺时针存点 逆时针存点得改为 l[j].a=p[j+1],l[j].b=p[j]
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <cmath>
#include <vector>
#define eps 1e-10
using namespace std;
int n,tot;
double ans;
struct P{double x,y;}p[1005],a[1005];
struct L{P a,b;double angle;}l[1005],q[1005];

int read() {
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}

P operator-(P a,P b) {
	P t;
	t.x=a.x-b.x;
	t.y=a.y-b.y;
	return t;
}

double operator*(P a,P b) {
	return a.x*b.y-a.y*b.x;
}

P inter(L a,L b) {
	double k1,k2,t;
	k1=(b.b-a.a)*(a.b-a.a);
	k2=(a.b-a.a)*(b.a-a.a);
	t=k1/(k1+k2);
	P ans;
	ans.x=b.b.x+(b.a.x-b.b.x)*t;
	ans.y=b.b.y+(b.a.y-b.b.y)*t;
	return ans;
}

bool cmp(L u, L v) {
	if (fabs(u.angle-v.angle)<eps) return (v.a-u.a)*(v.b-u.a) < eps;
	return u.angle < v.angle;
}

/*????????????????????????????????????????????????????????????*/
bool judge(L t, L a, L b) {
	P p=inter(a, b);
	return (t.a-p)*(t.b-p) > eps;//(或者这里改成<-eps)
}
/*????????????????????????????????????????????????????????????*/

/*????????????????????????????????????????????????????????????*/
bool cmp(L u, L v) {
	if (fabs(u.angle-v.angle)<eps) return (v.a.x-u.a.x)*(v.b.y-u.a.y)-(v.a.y-u.a.y)*(v.b.x-u.a.x) < eps;//(还要改这里)
	return u.angle < v.angle;
}
/*????????????????????????????????????????????????????????????*/

void hpi() {
	sort(l+1,l+n+1,cmp);
	int Left=1,R=0;tot=1;
	
	/*????????????????????????????????????????????????????????????*/
	for(int i=2;i<=n;i++)
	{
		if(l[i].angle-l[tot].angle>eps)
			l[++tot]=l[i];
	}
	/*????????????????????????????????????????????????????????????*/
	
	n=tot;tot=0;
	q[++R]=l[1];q[++R]=l[2];
	for(int i=3;i<=n;i++) {
		while(Left<R&&judge(l[i], q[R-1], q[R]))R--;
		while(Left<R&&judge(l[i], q[Left+1], q[Left]))Left++;
		q[++R]=l[i];
	}
	while(Left<R&&judge(q[Left], q[R-1], q[R]))R--;
	while(Left<R&&judge(q[R], q[Left+1], q[Left]))Left++;
	for(int i=Left;i<R;i++) a[++tot]=inter(q[i], q[i+1]);
	a[++tot]=inter(q[R], q[Left]);
}

double getarea() {
	if(tot<3) return 0.0 ;
	a[tot+1]=a[1];
	double area=0.0;
	for(int i=1;i<=tot;i++)
		area+=a[i]*a[i+1];
	return fabs(area)/2;
}

//double getArea() {
//	if (tot < 3) return 0.0;
//	double area = 0.0;
//	for (int i = 2; i < tot; i++)
//		area += multi(a[1], a[i], a[i+1]);
//	if (area < 0) area = -area;
//	return area/=2.0;
//}

int main() {
	int T;
	scanf("%d",&T);
	while (T--) {
		n=read();
		for(int j=1;j<=n;j++) p[j].x=read(),p[j].y=read();
		p[n+1]=p[1];
		for(int j=1;j<=n;j++) l[j].a=p[j],l[j].b=p[j+1];
		for(int i=1;i<=n;i++) l[i].angle=atan2(l[i].b.y-l[i].a.y,l[i].b.x-l[i].a.x);
		hpi();
		if (tot>2) printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
/*
2
4 0 0 0 1 1 1 1 0
8 0 0 0 2 1 2 1 1 2 1 2 2 3 2 3 0
*/